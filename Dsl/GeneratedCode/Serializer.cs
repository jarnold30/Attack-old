//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace JA.Attack
{
	/// <summary>
	/// Serializer NamedElementSerializer for DomainClass NamedElement.
	/// </summary>
	public partial class NamedElementSerializer : DslModeling::DomainClassXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// NamedElementSerializer Constructor
		/// </summary>
		public NamedElementSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// NamedElement is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the NamedElement element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory NamedElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			NamedElement instanceOfNamedElement = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instanceOfNamedElement != null, "Expecting an instance of NamedElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				string attribName = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "name");
				if (attribName != null)
				{
					global::System.String valueOfName;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribName, out valueOfName))
					{
						instanceOfNamedElement.Name = valueOfName;
					}
					else
					{	// Invalid property value, ignored.
						AttackSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "name", typeof(global::System.String), attribName);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of NamedElement based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized NamedElement, a new NamedElement instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created NamedElement instance, or null if the reader is not pointing to a serialized NamedElement instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "NamedElement".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					NamedElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NamedElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of NamedElement based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of NamedElement.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new NamedElement instance should be created.</param>	
		/// <returns>Created NamedElement instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from NamedElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from NamedElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NamedElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including NamedElement itself) instance of NamedElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "NamedElement".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					NamedElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as NamedElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of NamedElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, NamedElement.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from NamedElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from NamedElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(NamedElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized NamedElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the NamedElement instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the NamedElement instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of NamedElement cannot be monikerized.
			AttackSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "NamedElement");
		}
		
		/// <summary>
		/// Public Write() method that serializes one NamedElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">NamedElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			NamedElement instanceOfNamedElement = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instanceOfNamedElement != null, "Expecting an instance of NamedElement");
	
			// Name
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfNamedElement.Name;
				if (!serializationContext.Result.Failed)
				{
					AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "name", propValue);
				}
			}
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given NamedElement instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NamedElement instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the NamedElement instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NamedElement instance = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NamedElement!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">NamedElement instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			NamedElement instance = element as NamedElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of NamedElement!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer AttackGraphSerializer for DomainClass AttackGraph.
	/// </summary>
	public partial class AttackGraphSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// AttackGraphSerializer Constructor
		/// </summary>
		public AttackGraphSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of AttackGraph.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"attackGraph"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of AttackGraph.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"attackGraphMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of AttackGraph in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one AttackGraph instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the AttackGraph element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AttackGraph instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AttackGraph instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			AttackGraph instanceOfAttackGraph = element as AttackGraph;
			global::System.Diagnostics.Debug.Assert(instanceOfAttackGraph != null, "Expecting an instance of AttackGraph!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfAttackGraph, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory AttackGraph instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, AttackGraph element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "flowElements", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <flowElements>
						ReadAttackGraphHasFlowElementsInstances(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </flowElements>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship AttackGraphHasFlowElements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AttackGraph instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadAttackGraphHasFlowElementsInstances(DslModeling::SerializationContext serializationContext, AttackGraph element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newAttackGraphHasFlowElementsSerializer = serializationContext.Directory.GetSerializer(AttackGraphHasFlowElements.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newAttackGraphHasFlowElementsSerializer != null, "Cannot find serializer for AttackGraphHasFlowElements!");
				AttackGraphHasFlowElements newAttackGraphHasFlowElements = newAttackGraphHasFlowElementsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as AttackGraphHasFlowElements;
				if (newAttackGraphHasFlowElements != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newAttackGraphHasFlowElements, AttackGraphHasFlowElements.AttackGraphDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newAttackGraphHasFlowElements.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newAttackGraphHasFlowElements.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newAttackGraphHasFlowElements, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newFlowElementOfAttackGraphHasFlowElementsSerializer = serializationContext.Directory.GetSerializer(FlowElement.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newFlowElementOfAttackGraphHasFlowElementsSerializer != null, "Cannot find serializer for FlowElement!");
					FlowElement newFlowElementOfAttackGraphHasFlowElements = newFlowElementOfAttackGraphHasFlowElementsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as FlowElement;
					if (newFlowElementOfAttackGraphHasFlowElements != null)
					{
						AttackSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(AttackGraphHasFlowElements));
						element.FlowElements.Add(newFlowElementOfAttackGraphHasFlowElements);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newFlowElementOfAttackGraphHasFlowElements.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newFlowElementOfAttackGraphHasFlowElements.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newFlowElementOfAttackGraphHasFlowElements, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of AttackGraph based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized AttackGraph, a new AttackGraph instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created AttackGraph instance, or null if the reader is not pointing to a serialized AttackGraph instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "AttackGraph" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "AttackGraph".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						AttackGraphSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AttackGraphSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of AttackGraph based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of AttackGraph.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new AttackGraph instance should be created.</param>	
		/// <returns>Created AttackGraph instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new AttackGraph(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from AttackGraph, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from AttackGraph.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AttackGraph.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including AttackGraph itself) instance of AttackGraph based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "AttackGraph" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "AttackGraph".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						AttackGraphSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AttackGraphSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of AttackGraph based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, AttackGraph.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from AttackGraph, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from AttackGraph.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AttackGraph.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized AttackGraph instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackGraph instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the AttackGraph instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the AttackGraph instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one AttackGraph instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackGraph instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackGraph instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			AttackGraph instance = element as AttackGraph;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AttackGraph!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackGraph instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, AttackGraph element, global::System.Xml.XmlWriter writer)
		{
			// AttackGraphHasFlowElements
			global::System.Collections.ObjectModel.ReadOnlyCollection<AttackGraphHasFlowElements> allAttackGraphHasFlowElementsInstances = AttackGraphHasFlowElements.GetLinksToFlowElements(element);
			if (!serializationContext.Result.Failed && allAttackGraphHasFlowElementsInstances.Count > 0)
			{
				writer.WriteStartElement("flowElements");
				foreach (AttackGraphHasFlowElements eachAttackGraphHasFlowElementsInstance in allAttackGraphHasFlowElementsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachAttackGraphHasFlowElementsInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachAttackGraphHasFlowElementsInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachAttackGraphHasFlowElementsInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given AttackGraph instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AttackGraph instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the AttackGraph instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			AttackGraph instance = element as AttackGraph;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AttackGraph!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AttackGraph instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			AttackGraph instance = element as AttackGraph;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AttackGraph!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer FlowElementSerializer for DomainClass FlowElement.
	/// </summary>
	public partial class FlowElementSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// FlowElementSerializer Constructor
		/// </summary>
		public FlowElementSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// Cannot be serialized.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
	
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		
		/// <summary>
		/// Cannot be monikerized.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return string.Empty; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// FlowElement is abstract and cannot be instantiated, so this method throws NotSupportedException.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the FlowElement element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory FlowElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory FlowElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			FlowElement instanceOfFlowElement = element as FlowElement;
			global::System.Diagnostics.Debug.Assert(instanceOfFlowElement != null, "Expecting an instance of FlowElement");
	
			// Description
			if (!serializationContext.Result.Failed)
			{
				string attribDescription = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "description");
				if (attribDescription != null)
				{
					global::System.String valueOfDescription;
					if (DslModeling::SerializationUtilities.TryGetValue<global::System.String>(serializationContext, attribDescription, out valueOfDescription))
					{
						instanceOfFlowElement.Description = valueOfDescription;
					}
					else
					{	// Invalid property value, ignored.
						AttackSerializationBehaviorSerializationMessages.IgnoredPropertyValue(serializationContext, reader, "description", typeof(global::System.String), attribDescription);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory FlowElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			FlowElement instanceOfFlowElement = element as FlowElement;
			global::System.Diagnostics.Debug.Assert(instanceOfFlowElement != null, "Expecting an instance of FlowElement!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfFlowElement, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory FlowElement instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, FlowElement element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "flowTo", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <flowTo>
						ReadFlowInstances(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </flowTo>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship Flow.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory FlowElement instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
		private static void ReadFlowInstances(DslModeling::SerializationContext serializationContext, FlowElement element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newFlowSerializer = serializationContext.Directory.GetSerializer(Flow.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newFlowSerializer != null, "Cannot find serializer for Flow!");
				Flow newFlow = newFlowSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as Flow;
				if (newFlow != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newFlow, Flow.FlowFromDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newFlow.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newFlow.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newFlow, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newFlowElementMonikerOfFlowSerializer = serializationContext.Directory.GetSerializer(FlowElement.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newFlowElementMonikerOfFlowSerializer != null, "Cannot find serializer for FlowElement!");
					DslModeling::Moniker newFlowElementMonikerOfFlow = newFlowElementMonikerOfFlowSerializer.TryCreateMonikerInstance(serializationContext, reader, element, Flow.DomainClassId, element.Partition);
					if (newFlowElementMonikerOfFlow != null)
					{
						AttackSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(Flow));
						new Flow(element.Partition, new DslModeling::RoleAssignment(Flow.FlowFromDomainRoleId, element), new DslModeling::RoleAssignment(Flow.FlowToDomainRoleId, newFlowElementMonikerOfFlow));
						DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of FlowElement based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized FlowElement, a new FlowElement instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created FlowElement instance, or null if the reader is not pointing to a serialized FlowElement instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "FlowElement".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class instance.
					FlowElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as FlowElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of FlowElement based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of FlowElement.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new FlowElement instance should be created.</param>	
		/// <returns>Created FlowElement instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			// Abstract class, cannot be serialized.
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from FlowElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from FlowElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(FlowElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including FlowElement itself) instance of FlowElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				// Check for derived classes of "FlowElement".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					FlowElementSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as FlowElementSerializer;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of FlowElement based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, FlowElement.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from FlowElement, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from FlowElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(FlowElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized FlowElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">FlowElement instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the FlowElement instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the FlowElement instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			// Instance of FlowElement cannot be monikerized.
			AttackSerializationBehaviorSerializationMessages.CannotMonikerizeElement(serializationContext, "FlowElement");
		}
		
		/// <summary>
		/// Public Write() method that serializes one FlowElement instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">FlowElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			throw new global::System.NotSupportedException();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">FlowElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			FlowElement instanceOfFlowElement = element as FlowElement;
			global::System.Diagnostics.Debug.Assert(instanceOfFlowElement != null, "Expecting an instance of FlowElement");
	
			// Description
			if (!serializationContext.Result.Failed)
			{
				global::System.String propValue = instanceOfFlowElement.Description;
				if (!serializationContext.Result.Failed)
				{
					if (propValue != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(propValue, string.Empty) != 0))
					{	// No need to write the value out if it's the same as default value.
						AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "description", propValue);
					}
				}
			}
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">FlowElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			FlowElement instance = element as FlowElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of FlowElement!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">FlowElement instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, FlowElement element, global::System.Xml.XmlWriter writer)
		{
			// Flow
			global::System.Collections.ObjectModel.ReadOnlyCollection<Flow> allFlowInstances = Flow.GetLinksToFlowTo(element);
			if (!serializationContext.Result.Failed && allFlowInstances.Count > 0)
			{
				writer.WriteStartElement("flowTo");
				foreach (Flow eachFlowInstance in allFlowInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachFlowInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachFlowInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachFlowInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given FlowElement instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">FlowElement instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the FlowElement instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			FlowElement instance = element as FlowElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of FlowElement!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">FlowElement instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			FlowElement instance = element as FlowElement;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of FlowElement!");
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer TaskSerializer for DomainClass Task.
	/// </summary>
	public partial class TaskSerializer : FlowElementSerializer
	{
		#region Constructor
		/// <summary>
		/// TaskSerializer Constructor
		/// </summary>
		public TaskSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Task.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"task"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Task.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"taskMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Task in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Task instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Task element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Task instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Task instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			Task instanceOfTask = element as Task;
			global::System.Diagnostics.Debug.Assert(instanceOfTask != null, "Expecting an instance of Task!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfTask, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory Task instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, Task element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "conditioned", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <conditioned>
						ReadTaskHasPreConditionsInstances(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </conditioned>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship TaskHasPreConditions.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Task instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadTaskHasPreConditionsInstances(DslModeling::SerializationContext serializationContext, Task element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newTaskHasPreConditionsSerializer = serializationContext.Directory.GetSerializer(TaskHasPreConditions.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newTaskHasPreConditionsSerializer != null, "Cannot find serializer for TaskHasPreConditions!");
				TaskHasPreConditions newTaskHasPreConditions = newTaskHasPreConditionsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as TaskHasPreConditions;
				if (newTaskHasPreConditions != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newTaskHasPreConditions, TaskHasPreConditions.TaskDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newTaskHasPreConditions.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newTaskHasPreConditions.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newTaskHasPreConditions, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newConditionOfTaskHasPreConditionsSerializer = serializationContext.Directory.GetSerializer(Condition.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newConditionOfTaskHasPreConditionsSerializer != null, "Cannot find serializer for Condition!");
					Condition newConditionOfTaskHasPreConditions = newConditionOfTaskHasPreConditionsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Condition;
					if (newConditionOfTaskHasPreConditions != null)
					{
						AttackSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(TaskHasPreConditions));
						element.Conditioned.Add(newConditionOfTaskHasPreConditions);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newConditionOfTaskHasPreConditions.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newConditionOfTaskHasPreConditions.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newConditionOfTaskHasPreConditions, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Task based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Task, a new Task instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Task instance, or null if the reader is not pointing to a serialized Task instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Task" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Task".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TaskSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TaskSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Task based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Task.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Task instance should be created.</param>	
		/// <returns>Created Task instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Task(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Task, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Task.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Task.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Task itself) instance of Task based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Task" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Task".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TaskSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TaskSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Task based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Task.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Task, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Task.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Task.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Task instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Task instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Task instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Task instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Task instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Task instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Task instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			Task instance = element as Task;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Task!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Task instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, Task element, global::System.Xml.XmlWriter writer)
		{
			// TaskHasPreConditions
			global::System.Collections.ObjectModel.ReadOnlyCollection<TaskHasPreConditions> allTaskHasPreConditionsInstances = TaskHasPreConditions.GetLinksToConditioned(element);
			if (!serializationContext.Result.Failed && allTaskHasPreConditionsInstances.Count > 0)
			{
				writer.WriteStartElement("conditioned");
				foreach (TaskHasPreConditions eachTaskHasPreConditionsInstance in allTaskHasPreConditionsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachTaskHasPreConditionsInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachTaskHasPreConditionsInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachTaskHasPreConditionsInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Task instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Task instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Task instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Task instance = element as Task;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Task!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Task instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Task instance = element as Task;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Task!");
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer StartPointSerializer for DomainClass StartPoint.
	/// </summary>
	public partial class StartPointSerializer : FlowElementSerializer
	{
		#region Constructor
		/// <summary>
		/// StartPointSerializer Constructor
		/// </summary>
		public StartPointSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of StartPoint.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"startPoint"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of StartPoint.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"startPointMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of StartPoint in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one StartPoint instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the StartPoint element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory StartPoint instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of StartPoint based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized StartPoint, a new StartPoint instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created StartPoint instance, or null if the reader is not pointing to a serialized StartPoint instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "StartPoint" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "StartPoint".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						StartPointSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StartPointSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of StartPoint based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of StartPoint.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new StartPoint instance should be created.</param>	
		/// <returns>Created StartPoint instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new StartPoint(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from StartPoint, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from StartPoint.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(StartPoint.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including StartPoint itself) instance of StartPoint based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "StartPoint" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "StartPoint".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						StartPointSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StartPointSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of StartPoint based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, StartPoint.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from StartPoint, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from StartPoint.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(StartPoint.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized StartPoint instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StartPoint instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the StartPoint instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the StartPoint instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one StartPoint instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StartPoint instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given StartPoint instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">StartPoint instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the StartPoint instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			StartPoint instance = element as StartPoint;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of StartPoint!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">StartPoint instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			StartPoint instance = element as StartPoint;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of StartPoint!");
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer EndpointSerializer for DomainClass Endpoint.
	/// </summary>
	public partial class EndpointSerializer : FlowElementSerializer
	{
		#region Constructor
		/// <summary>
		/// EndpointSerializer Constructor
		/// </summary>
		public EndpointSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Endpoint.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"endpoint"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Endpoint.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"endpointMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Endpoint in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Endpoint instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Endpoint element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Endpoint instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Endpoint based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Endpoint, a new Endpoint instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Endpoint instance, or null if the reader is not pointing to a serialized Endpoint instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Endpoint" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Endpoint".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						EndpointSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EndpointSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Endpoint based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Endpoint.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Endpoint instance should be created.</param>	
		/// <returns>Created Endpoint instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Endpoint(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Endpoint, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Endpoint.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Endpoint.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Endpoint itself) instance of Endpoint based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Endpoint" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Endpoint".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EndpointSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EndpointSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Endpoint based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Endpoint.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Endpoint, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Endpoint.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Endpoint.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Endpoint instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Endpoint instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Endpoint instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Endpoint instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Endpoint instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Endpoint instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Endpoint instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Endpoint instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Endpoint instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Endpoint instance = element as Endpoint;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Endpoint!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Endpoint instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Endpoint instance = element as Endpoint;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Endpoint!");
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer MergeBranchSerializer for DomainClass MergeBranch.
	/// </summary>
	public partial class MergeBranchSerializer : FlowElementSerializer
	{
		#region Constructor
		/// <summary>
		/// MergeBranchSerializer Constructor
		/// </summary>
		public MergeBranchSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of MergeBranch.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"mergeBranch"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of MergeBranch.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"mergeBranchMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of MergeBranch in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one MergeBranch instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the MergeBranch element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory MergeBranch instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of MergeBranch based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized MergeBranch, a new MergeBranch instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created MergeBranch instance, or null if the reader is not pointing to a serialized MergeBranch instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "MergeBranch" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "MergeBranch".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						MergeBranchSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as MergeBranchSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of MergeBranch based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of MergeBranch.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new MergeBranch instance should be created.</param>	
		/// <returns>Created MergeBranch instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new MergeBranch(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from MergeBranch, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from MergeBranch.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(MergeBranch.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including MergeBranch itself) instance of MergeBranch based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "MergeBranch" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "MergeBranch".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						MergeBranchSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as MergeBranchSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of MergeBranch based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, MergeBranch.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from MergeBranch, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from MergeBranch.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(MergeBranch.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized MergeBranch instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">MergeBranch instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the MergeBranch instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the MergeBranch instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one MergeBranch instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">MergeBranch instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given MergeBranch instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">MergeBranch instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the MergeBranch instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			MergeBranch instance = element as MergeBranch;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of MergeBranch!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">MergeBranch instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			MergeBranch instance = element as MergeBranch;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of MergeBranch!");
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer SynchronizationSerializer for DomainClass Synchronization.
	/// </summary>
	public partial class SynchronizationSerializer : FlowElementSerializer
	{
		#region Constructor
		/// <summary>
		/// SynchronizationSerializer Constructor
		/// </summary>
		public SynchronizationSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Synchronization.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"synchronization"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Synchronization.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"synchronizationMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Synchronization in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Synchronization instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Synchronization element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Synchronization instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Synchronization based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Synchronization, a new Synchronization instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Synchronization instance, or null if the reader is not pointing to a serialized Synchronization instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Synchronization" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Synchronization".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						SynchronizationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as SynchronizationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Synchronization based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Synchronization.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Synchronization instance should be created.</param>	
		/// <returns>Created Synchronization instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Synchronization(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Synchronization, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Synchronization.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Synchronization.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Synchronization itself) instance of Synchronization based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Synchronization" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Synchronization".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						SynchronizationSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as SynchronizationSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Synchronization based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Synchronization.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Synchronization, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Synchronization.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Synchronization.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Synchronization instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Synchronization instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Synchronization instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Synchronization instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Synchronization instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Synchronization instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Synchronization instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Synchronization instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Synchronization instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Synchronization instance = element as Synchronization;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Synchronization!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Synchronization instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Synchronization instance = element as Synchronization;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Synchronization!");
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer StateSerializer for DomainClass State.
	/// </summary>
	public partial class StateSerializer : FlowElementSerializer
	{
		#region Constructor
		/// <summary>
		/// StateSerializer Constructor
		/// </summary>
		public StateSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of State.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"state"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of State.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"stateMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of State in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one State instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the State element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory State instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory State instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
			State instanceOfState = element as State;
			global::System.Diagnostics.Debug.Assert(instanceOfState != null, "Expecting an instance of State!");
	
			// Read child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				ReadChildElements(serializationContext, instanceOfState, reader);
		}
	
		/// <summary>
		/// This method deserializes all child model elements.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first child XML element to deserialized.
		/// This method will read as many child elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
		///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
		///    should return immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="element">In-memory State instance that will get the deserialized data.</param>
		private static void ReadChildElements(DslModeling::SerializationContext serializationContext, State element, global::System.Xml.XmlReader reader)
		{
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				if (string.Compare(reader.LocalName, "conditioned", global::System.StringComparison.CurrentCulture) == 0)
				{
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <conditioned>
						ReadStateHasPostConditionsInstances(serializationContext, element, reader);
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </conditioned>
					}
				}
			}
		}
	
		/// <summary>
		/// Reads all instances of relationship StateHasPostConditions.
		/// </summary>
		/// <remarks>
		/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
		/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
		/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory State instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		private static void ReadStateHasPostConditionsInstances(DslModeling::SerializationContext serializationContext, State element, global::System.Xml.XmlReader reader)
		{
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				DslModeling::DomainClassXmlSerializer newStateHasPostConditionsSerializer = serializationContext.Directory.GetSerializer(StateHasPostConditions.DomainClassId);
				global::System.Diagnostics.Debug.Assert(newStateHasPostConditionsSerializer != null, "Cannot find serializer for StateHasPostConditions!");
				StateHasPostConditions newStateHasPostConditions = newStateHasPostConditionsSerializer.TryCreateInstance (serializationContext, reader, element.Partition) as StateHasPostConditions;
				if (newStateHasPostConditions != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (newStateHasPostConditions, StateHasPostConditions.StateDomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newStateHasPostConditions.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newStateHasPostConditions.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, newStateHasPostConditions, reader);
				}
				else
				{	// Maybe the relationship is serialized in short-form by mistake.
					DslModeling::DomainClassXmlSerializer newConditionOfStateHasPostConditionsSerializer = serializationContext.Directory.GetSerializer(Condition.DomainClassId);
					global::System.Diagnostics.Debug.Assert(newConditionOfStateHasPostConditionsSerializer != null, "Cannot find serializer for Condition!");
					Condition newConditionOfStateHasPostConditions = newConditionOfStateHasPostConditionsSerializer.TryCreateInstance(serializationContext, reader, element.Partition) as Condition;
					if (newConditionOfStateHasPostConditions != null)
					{
						AttackSerializationBehaviorSerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(StateHasPostConditions));
						element.Conditioned.Add(newConditionOfStateHasPostConditions);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (newConditionOfStateHasPostConditions.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + newConditionOfStateHasPostConditions.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, newConditionOfStateHasPostConditions, reader);
					}
					else
					{	// Unknown element, skip.
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
		}
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of State based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized State, a new State instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created State instance, or null if the reader is not pointing to a serialized State instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "State" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "State".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						StateSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StateSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of State based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of State.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new State instance should be created.</param>	
		/// <returns>Created State instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new State(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from State, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from State.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(State.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including State itself) instance of State based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "State" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "State".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						StateSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StateSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of State based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, State.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from State, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from State.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(State.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized State instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">State instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the State instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the State instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one State instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">State instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">State instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
			State instance = element as State;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of State!");
	
			// Write child model elements (which are always serialized as nested XML elements).
			if (!serializationContext.Result.Failed)
				WriteChildElements(serializationContext, instance, writer);
		}
		
	
		/// <summary>
		/// Serialize all child model elements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">State instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		private static void WriteChildElements(DslModeling::SerializationContext serializationContext, State element, global::System.Xml.XmlWriter writer)
		{
			// StateHasPostConditions
			global::System.Collections.ObjectModel.ReadOnlyCollection<StateHasPostConditions> allStateHasPostConditionsInstances = StateHasPostConditions.GetLinksToConditioned(element);
			if (!serializationContext.Result.Failed && allStateHasPostConditionsInstances.Count > 0)
			{
				writer.WriteStartElement("conditioned");
				foreach (StateHasPostConditions eachStateHasPostConditionsInstance in allStateHasPostConditionsInstances)
				{
					if (serializationContext.Result.Failed)
						break;
	
					DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(eachStateHasPostConditionsInstance.GetDomainClass().Id);
					global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + eachStateHasPostConditionsInstance.GetDomainClass().Name + "!");
					relSerializer.Write(serializationContext, eachStateHasPostConditionsInstance, writer);
				}
				writer.WriteEndElement();
			}
	
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given State instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">State instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the State instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			State instance = element as State;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of State!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">State instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			State instance = element as State;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of State!");
			DslModeling::ModelElement container = instance.AttackGraph;
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer ConditionSerializer for DomainClass Condition.
	/// </summary>
	public partial class ConditionSerializer : NamedElementSerializer
	{
		#region Constructor
		/// <summary>
		/// ConditionSerializer Constructor
		/// </summary>
		public ConditionSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Condition.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"condition"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Condition.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"conditionMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Condition in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"name"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Condition instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Condition element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Condition instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of Condition based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Condition, a new Condition instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Condition instance, or null if the reader is not pointing to a serialized Condition instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Condition" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Condition".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						ConditionSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ConditionSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Condition based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Condition.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Condition instance should be created.</param>	
		/// <returns>Created Condition instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new Condition(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Condition, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Condition.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Condition.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Condition itself) instance of Condition based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Condition" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Condition".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						ConditionSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as ConditionSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Condition based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
			DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, Condition.DomainClassId, monikerString, partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Condition, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Condition.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Condition.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Condition instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Condition instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Condition instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Condition instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Condition instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Condition instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Condition instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Condition instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Condition instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Condition instance = element as Condition;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Condition!");
	
			string key = instance.Name;
			string containerMoniker = null;
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				containerMoniker = containerSerializer.CalculateQualifiedName(directory, container);
			}
			if (string.IsNullOrEmpty(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}", key);
			}
			else if (DslModeling::SimpleMonikerResolver.IsFullyQualified(containerMoniker))
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", containerMoniker, key);
			}
			else
			{
				return string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "/{0}/{1}", containerMoniker, key);
			}
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Condition instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Condition instance = element as Condition;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Condition!");
			DslModeling::ModelElement container = DslModeling::DomainClassInfo.FindEmbeddingElement(instance);
			if(container != null)
			{
				DslModeling::DomainClassXmlSerializer containerSerializer = directory.GetSerializer(container.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(containerSerializer != null, "Cannot find serializer for " + container.GetDomainClass().Name + "!");
				return containerSerializer.GetMonikerQualifier(directory, container);
			}
			else
			{
				return string.Empty;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer FlowSerializer for DomainClass Flow.
	/// </summary>
	public partial class FlowSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// FlowSerializer Constructor
		/// </summary>
		public FlowSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of Flow.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"flow"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of Flow.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"flowMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of Flow in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one Flow instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the Flow element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Flow instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the monikerized instance of target role-player FlowTo
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player FlowTo.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					AttackSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "Flow");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player FlowTo.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Flow instance that will link to the target FlowElement instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the monikerized instance of target role-player FlowTo
			DslModeling::Moniker targetRoleMoniker = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(FlowElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for FlowElement!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRoleMoniker = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((Flow)element).FlowFrom, Flow.DomainClassId, element.Partition);
				if (targetRoleMoniker != null)
				{
					// Attach the target role-player moniker.
					DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, Flow.FlowToDomainRoleId, targetRoleMoniker);
					// Moniker tag has no child XML elements in it, so just skip to the next element.
					DslModeling::SerializationUtilities.Skip(reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRoleMoniker == null)
			{
				AttackSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "Flow");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Flow instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory Flow instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of Flow based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized Flow, a new Flow instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created Flow instance, or null if the reader is not pointing to a serialized Flow instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of Flow based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// Flow type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from Flow, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Flow" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "Flow".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						FlowSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as FlowSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of Flow based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of Flow.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new Flow instance should be created.</param>	
		/// <returns>Created Flow instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new Flow(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (Flow.FlowFromDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (Flow.FlowToDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from Flow, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from Flow.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Flow.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including Flow itself) instance of Flow based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "Flow" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "Flow".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						FlowSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as FlowSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of Flow based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, Flow.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from Flow, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from Flow.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(Flow.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized Flow instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Flow instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the Flow instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the Flow instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one Flow instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Flow instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			Flow instance = element as Flow;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Flow!");
	
			DslModeling::ModelElement targetElement = instance.FlowTo;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.FlowFrom, this);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Flow instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">Flow instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given Flow instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Flow instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the Flow instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			Flow instance = element as Flow;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of Flow!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">Flow instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	
		#region Monikerization Support
		/// <summary>
		/// Calculates a Moniker, given a reference to a FlowElement
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Instance of FlowElement that contains the given serialized reference</param>
		/// <param name="domainClassId">DomainClassId of the model element that the given moniker string will be resolved to.</param>
		/// <param name="monikerString">Serialized string reference to an instance of FlowElement</param>
		/// <param name="store">Store where the Moniker will be created</param>
		/// <returns>A Moniker encapsulating the serialized string reference of FlowElement instance</returns>
		public override DslModeling::Moniker MonikerizeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, global::System.Guid domainClassId, string monikerString, DslModeling::Store store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is FlowElement, "Expecting an instance of FlowElement!");
			global::System.Diagnostics.Debug.Assert (!string.IsNullOrEmpty (monikerString));
			if (string.IsNullOrEmpty (monikerString))
				throw new global::System.ArgumentNullException ("monikerString");
			global::System.Diagnostics.Debug.Assert(store != null);
			if (store == null)
				throw new global::System.ArgumentNullException ("store");
			#endregion
			
			DslModeling::MonikerKey key = null;
			if (DslModeling::SimpleMonikerResolver.IsFullyQualified(monikerString))
			{
				key = new DslModeling::MonikerKey(monikerString, Flow.DomainClassId, domainClassId, store);
			}
			else
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				key = new DslModeling::MonikerKey(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, "{0}/{1}", sourceQualifier, monikerString), Flow.DomainClassId, domainClassId, store);
			}
			return new DslModeling::Moniker(key, store);
		}
	
		/// <summary>
		/// Calculates a monikerized string reference to a FlowElement.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="sourceElement">Source side of reference relationship. The referenced target element will be serialized.</param>
		/// <param name="targetElement">Target side of relationship that will be serialized.</param>
		/// <returns>A monikerized string reference to target element.</returns>		
		public override string SerializeReference(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement sourceElement, DslModeling::ModelElement targetElement)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(sourceElement != null);
			if (sourceElement == null)
				throw new global::System.ArgumentNullException ("sourceElement");
			global::System.Diagnostics.Debug.Assert (sourceElement is FlowElement, "Expecting an instance of FlowElement!");
			global::System.Diagnostics.Debug.Assert(targetElement != null);
			if (targetElement == null)
				throw new global::System.ArgumentNullException ("targetElement");
			global::System.Diagnostics.Debug.Assert (targetElement is FlowElement, "Expecting an instance of FlowElement!");
			#endregion
			
			// full form reference
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			string targetMoniker = targetSerializer.CalculateQualifiedName(serializationContext.Directory, targetElement);
			string targetQualifier = targetSerializer.GetMonikerQualifier(serializationContext.Directory, targetElement);
			
			if (!string.IsNullOrEmpty(targetQualifier))
			{
				DslModeling::DomainClassXmlSerializer sourceSerializer = serializationContext.Directory.GetSerializer(sourceElement.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(sourceSerializer != null, "Cannot find serializer for " + sourceElement.GetDomainClass().Name + "!");
				string sourceQualifier = sourceSerializer.GetMonikerQualifier(serializationContext.Directory, sourceElement);
				if (string.Compare(targetQualifier, sourceQualifier, global::System.StringComparison.CurrentCulture) == 0)
				{
					// See if we can create a short form reference by omitting the qualifier
					global::System.Diagnostics.Debug.Assert(targetMoniker.StartsWith(targetQualifier + "/", global::System.StringComparison.CurrentCulture));
					string shortFormTargetMoniker = targetMoniker.Substring(targetQualifier.Length + 1);
					if (!DslModeling::SimpleMonikerResolver.IsFullyQualified(shortFormTargetMoniker))
						targetMoniker = shortFormTargetMoniker;
				}
			}
	
			return targetMoniker;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer AttackGraphHasFlowElementsSerializer for DomainClass AttackGraphHasFlowElements.
	/// </summary>
	public partial class AttackGraphHasFlowElementsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// AttackGraphHasFlowElementsSerializer Constructor
		/// </summary>
		public AttackGraphHasFlowElementsSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of AttackGraphHasFlowElements.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"attackGraphHasFlowElements"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of AttackGraphHasFlowElements.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"attackGraphHasFlowElementsMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of AttackGraphHasFlowElements in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one AttackGraphHasFlowElements instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the AttackGraphHasFlowElements element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AttackGraphHasFlowElements instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player FlowElement
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player FlowElement.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					AttackSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "AttackGraphHasFlowElements");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player FlowElement.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AttackGraphHasFlowElements instance that will link to the target FlowElement instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player FlowElement
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(FlowElement.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for FlowElement!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, AttackGraphHasFlowElements.FlowElementDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				AttackSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "AttackGraphHasFlowElements");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AttackGraphHasFlowElements instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AttackGraphHasFlowElements instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of AttackGraphHasFlowElements based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized AttackGraphHasFlowElements, a new AttackGraphHasFlowElements instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created AttackGraphHasFlowElements instance, or null if the reader is not pointing to a serialized AttackGraphHasFlowElements instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of AttackGraphHasFlowElements based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// AttackGraphHasFlowElements type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from AttackGraphHasFlowElements, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "AttackGraphHasFlowElements" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "AttackGraphHasFlowElements".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						AttackGraphHasFlowElementsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AttackGraphHasFlowElementsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of AttackGraphHasFlowElements based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of AttackGraphHasFlowElements.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new AttackGraphHasFlowElements instance should be created.</param>	
		/// <returns>Created AttackGraphHasFlowElements instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new AttackGraphHasFlowElements(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (AttackGraphHasFlowElements.AttackGraphDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (AttackGraphHasFlowElements.FlowElementDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from AttackGraphHasFlowElements, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from AttackGraphHasFlowElements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AttackGraphHasFlowElements.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including AttackGraphHasFlowElements itself) instance of AttackGraphHasFlowElements based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "AttackGraphHasFlowElements" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "AttackGraphHasFlowElements".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						AttackGraphHasFlowElementsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AttackGraphHasFlowElementsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of AttackGraphHasFlowElements based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, AttackGraphHasFlowElements.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from AttackGraphHasFlowElements, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from AttackGraphHasFlowElements.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AttackGraphHasFlowElements.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized AttackGraphHasFlowElements instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackGraphHasFlowElements instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the AttackGraphHasFlowElements instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the AttackGraphHasFlowElements instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one AttackGraphHasFlowElements instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackGraphHasFlowElements instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			AttackGraphHasFlowElements instance = element as AttackGraphHasFlowElements;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AttackGraphHasFlowElements!");
	
			DslModeling::ModelElement targetElement = instance.FlowElement;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackGraphHasFlowElements instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackGraphHasFlowElements instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given AttackGraphHasFlowElements instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AttackGraphHasFlowElements instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the AttackGraphHasFlowElements instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			AttackGraphHasFlowElements instance = element as AttackGraphHasFlowElements;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AttackGraphHasFlowElements!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AttackGraphHasFlowElements instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer TaskHasPreConditionsSerializer for DomainClass TaskHasPreConditions.
	/// </summary>
	public partial class TaskHasPreConditionsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// TaskHasPreConditionsSerializer Constructor
		/// </summary>
		public TaskHasPreConditionsSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TaskHasPreConditions.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"taskHasPreConditions"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TaskHasPreConditions.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"taskHasPreConditionsMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TaskHasPreConditions in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TaskHasPreConditions instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TaskHasPreConditions element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TaskHasPreConditions instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Condition
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Condition.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					AttackSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TaskHasPreConditions");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Condition.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TaskHasPreConditions instance that will link to the target Condition instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Condition
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Condition.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Condition!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, TaskHasPreConditions.ConditionDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				AttackSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "TaskHasPreConditions");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TaskHasPreConditions instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TaskHasPreConditions instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of TaskHasPreConditions based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TaskHasPreConditions, a new TaskHasPreConditions instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TaskHasPreConditions instance, or null if the reader is not pointing to a serialized TaskHasPreConditions instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of TaskHasPreConditions based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// TaskHasPreConditions type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from TaskHasPreConditions, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TaskHasPreConditions" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TaskHasPreConditions".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						TaskHasPreConditionsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TaskHasPreConditionsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TaskHasPreConditions based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TaskHasPreConditions.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TaskHasPreConditions instance should be created.</param>	
		/// <returns>Created TaskHasPreConditions instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new TaskHasPreConditions(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TaskHasPreConditions.TaskDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (TaskHasPreConditions.ConditionDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TaskHasPreConditions, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TaskHasPreConditions.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TaskHasPreConditions.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TaskHasPreConditions itself) instance of TaskHasPreConditions based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TaskHasPreConditions" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TaskHasPreConditions".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TaskHasPreConditionsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TaskHasPreConditionsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TaskHasPreConditions based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TaskHasPreConditions.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TaskHasPreConditions, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TaskHasPreConditions.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TaskHasPreConditions.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TaskHasPreConditions instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TaskHasPreConditions instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TaskHasPreConditions instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TaskHasPreConditions instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TaskHasPreConditions instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TaskHasPreConditions instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			TaskHasPreConditions instance = element as TaskHasPreConditions;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TaskHasPreConditions!");
	
			DslModeling::ModelElement targetElement = instance.Condition;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TaskHasPreConditions instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TaskHasPreConditions instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TaskHasPreConditions instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TaskHasPreConditions instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TaskHasPreConditions instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TaskHasPreConditions instance = element as TaskHasPreConditions;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TaskHasPreConditions!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TaskHasPreConditions instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer StateHasPostConditionsSerializer for DomainClass StateHasPostConditions.
	/// </summary>
	public partial class StateHasPostConditionsSerializer : DslModeling::DomainRelationshipXmlSerializer
	{
		#region Constructor
		/// <summary>
		/// StateHasPostConditionsSerializer Constructor
		/// </summary>
		public StateHasPostConditionsSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of StateHasPostConditions.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"stateHasPostConditions"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of StateHasPostConditions.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"stateHasPostConditionsMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of StateHasPostConditions in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one StateHasPostConditions instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the StateHasPostConditions element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory StateHasPostConditions instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			ReadPropertiesFromAttributes(serializationContext, element, reader);
				
			// Read nested XML elements, which include at least the instance of target role-player Condition
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read target role-player Condition.
					ReadTargetRolePlayer(serializationContext, element, reader);
	
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
				else
				{
					AttackSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "StateHasPostConditions");
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		/// <summary>
		/// This method reads the target role player Condition.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
		/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
		/// 1) The open tag of the target role player.
		/// 2) The end tag of the parent element (dangling relationship).
		/// 3) EOF (dangling relationship).
		/// After the call, the reader is positioned at:
		/// 1) The open tag of the next child element after the target role player.
		/// 2) The end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory StateHasPostConditions instance that will link to the target Condition instance.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected virtual void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
	
			// Read the instance of target role-player Condition
			DslModeling::ModelElement targetRolePlayer = null;
			DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(Condition.DomainClassId);
			global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for Condition!");
	
			while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				targetRolePlayer = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
				if (targetRolePlayer != null)
				{
					// Attach the target role-player.
					DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, StateHasPostConditions.ConditionDomainRoleId, targetRolePlayer);
					// Read target role-player.
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (targetRolePlayer.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + targetRolePlayer.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, targetRolePlayer, reader);
					break;
				}
				// Encountered one unknown XML element, skip it and keep reading.
				AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				DslModeling::SerializationUtilities.Skip(reader);
			}
			if (targetRolePlayer == null)
			{
				AttackSerializationBehaviorSerializationMessages.DanglingRelationship(serializationContext, reader, "StateHasPostConditions");
			}
		}
	
		/// <summary>
		/// This method deserializes all properties that are serialized as XML attributes.
		/// </summary>
		/// <remarks>
		/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
		/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory StateHasPostConditions instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// There is no property to read; do nothing
		}
	
		/// <summary>
		/// This methods deserializes nested XML elements inside the passed-in element.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
		/// reader at the open tag of the first child XML element.
		/// This method will read as many child XML elements as it can. It returns under three circumstances:
		/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
		///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
		///    immediately and do nothing.
		/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
		/// 3) EOF.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory StateHasPostConditions instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			// Always call the base class so any extensions are deserialized
			base.ReadElements(serializationContext, element, reader);
	
		}
	
		#region TryCreateInstance & TryCreateDerivedInstance
		/// <summary>
		/// This method creates a correct instance of StateHasPostConditions based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized StateHasPostConditions, a new StateHasPostConditions instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created StateHasPostConditions instance, or null if the reader is not pointing to a serialized StateHasPostConditions instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
		}
	
		/// <summary>
		/// This method creates a correct derived instance of StateHasPostConditions based on the tag currently pointed by the reader.
		/// Note that the difference between this method and the above one is that this method will never create an instance of the
		/// StateHasPostConditions type itself, only derived types are checked.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <returns>Created instance that derives from StateHasPostConditions, or null if the reader is not pointing to such a serialized instance.</returns>
		public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
		}
	
		/// <summary>
		/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>
		/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
		private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
		{
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (!derivedTypesOnly && string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "StateHasPostConditions" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "StateHasPostConditions".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived relationship instance.
						StateHasPostConditionsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StateHasPostConditionsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of StateHasPostConditions based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of StateHasPostConditions.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new StateHasPostConditions instance should be created.</param>	
		/// <returns>Created StateHasPostConditions instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				// Create the link with place-holder role-players.
				return new StateHasPostConditions(
					partition,
					new DslModeling::RoleAssignment[] {
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (StateHasPostConditions.StateDomainRoleId), 
						DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (StateHasPostConditions.ConditionDomainRoleId)
					},
					new DslModeling::PropertyAssignment[] {
						new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
					}
				);
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from StateHasPostConditions, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from StateHasPostConditions.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(StateHasPostConditions.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including StateHasPostConditions itself) instance of StateHasPostConditions based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "StateHasPostConditions" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "StateHasPostConditions".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						StateHasPostConditionsSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StateHasPostConditionsSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of StateHasPostConditions based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, StateHasPostConditions.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from StateHasPostConditions, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from StateHasPostConditions.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(StateHasPostConditions.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized StateHasPostConditions instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StateHasPostConditions instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the StateHasPostConditions instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the StateHasPostConditions instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one StateHasPostConditions instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StateHasPostConditions instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			// Write the target role-player instance.
			StateHasPostConditions instance = element as StateHasPostConditions;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of StateHasPostConditions!");
	
			DslModeling::ModelElement targetElement = instance.Condition;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
			targetSerializer.Write(serializationContext, targetElement, writer);
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
	
		/// <summary>
		/// Write all properties that need to be serialized as XML attributes.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StateHasPostConditions instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param> 
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
		protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// There are no properties; do nothing
		}
	
		/// <summary>
		/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StateHasPostConditions instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>        
		protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
		{
			// Always call the base class so any extensions are serialized
			base.WriteElements(serializationContext, element, writer);
	
		}
		
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given StateHasPostConditions instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">StateHasPostConditions instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the StateHasPostConditions instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			StateHasPostConditions instance = element as StateHasPostConditions;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of StateHasPostConditions!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">StateHasPostConditions instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
		
		#region Overrides to provide metadata at runtime
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing Id.
		/// </summary>
		public override bool SerializesId
		{
			get
			{
				return true;
			}
		}
	
		/// <summary>
		/// Exposes whether serializers derived from this class are serializing this relationship in full form.
		/// </summary>
		public override bool UsesFullForm
		{
			get
			{
				return true;
			}
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer MergeBranchShapeSerializer for DomainClass MergeBranchShape.
	/// </summary>
	public partial class MergeBranchShapeSerializer : DslDiagrams::ImageShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// MergeBranchShapeSerializer Constructor
		/// </summary>
		public MergeBranchShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of MergeBranchShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"mergeBranchShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of MergeBranchShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"mergeBranchShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of MergeBranchShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one MergeBranchShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the MergeBranchShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory MergeBranchShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of MergeBranchShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized MergeBranchShape, a new MergeBranchShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created MergeBranchShape instance, or null if the reader is not pointing to a serialized MergeBranchShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "MergeBranchShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "MergeBranchShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						MergeBranchShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as MergeBranchShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of MergeBranchShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of MergeBranchShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new MergeBranchShape instance should be created.</param>	
		/// <returns>Created MergeBranchShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new MergeBranchShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from MergeBranchShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from MergeBranchShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(MergeBranchShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including MergeBranchShape itself) instance of MergeBranchShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "MergeBranchShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "MergeBranchShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						MergeBranchShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as MergeBranchShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of MergeBranchShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, MergeBranchShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from MergeBranchShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from MergeBranchShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(MergeBranchShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized MergeBranchShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">MergeBranchShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the MergeBranchShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the MergeBranchShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one MergeBranchShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">MergeBranchShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given MergeBranchShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">MergeBranchShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the MergeBranchShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			MergeBranchShape instance = element as MergeBranchShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of MergeBranchShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">MergeBranchShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer EndShapeSerializer for DomainClass EndShape.
	/// </summary>
	public partial class EndShapeSerializer : DslDiagrams::ImageShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// EndShapeSerializer Constructor
		/// </summary>
		public EndShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of EndShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"endShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of EndShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"endShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of EndShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one EndShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the EndShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory EndShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of EndShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized EndShape, a new EndShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created EndShape instance, or null if the reader is not pointing to a serialized EndShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EndShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "EndShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						EndShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EndShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of EndShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of EndShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new EndShape instance should be created.</param>	
		/// <returns>Created EndShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new EndShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from EndShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from EndShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EndShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including EndShape itself) instance of EndShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "EndShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "EndShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						EndShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as EndShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of EndShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, EndShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from EndShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from EndShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(EndShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized EndShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EndShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the EndShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the EndShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one EndShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">EndShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given EndShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EndShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the EndShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			EndShape instance = element as EndShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of EndShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">EndShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer StartShapeSerializer for DomainClass StartShape.
	/// </summary>
	public partial class StartShapeSerializer : DslDiagrams::ImageShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// StartShapeSerializer Constructor
		/// </summary>
		public StartShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of StartShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"startShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of StartShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"startShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of StartShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one StartShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the StartShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory StartShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of StartShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized StartShape, a new StartShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created StartShape instance, or null if the reader is not pointing to a serialized StartShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "StartShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "StartShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						StartShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StartShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of StartShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of StartShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new StartShape instance should be created.</param>	
		/// <returns>Created StartShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new StartShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from StartShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from StartShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(StartShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including StartShape itself) instance of StartShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "StartShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "StartShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						StartShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StartShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of StartShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, StartShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from StartShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from StartShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(StartShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized StartShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StartShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the StartShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the StartShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one StartShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StartShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given StartShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">StartShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the StartShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			StartShape instance = element as StartShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of StartShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">StartShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer SyncBarShapeSerializer for DomainClass SyncBarShape.
	/// </summary>
	public partial class SyncBarShapeSerializer : DslDiagrams::NodeShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// SyncBarShapeSerializer Constructor
		/// </summary>
		public SyncBarShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of SyncBarShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"syncBarShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of SyncBarShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"syncBarShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of SyncBarShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one SyncBarShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the SyncBarShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory SyncBarShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of SyncBarShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized SyncBarShape, a new SyncBarShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created SyncBarShape instance, or null if the reader is not pointing to a serialized SyncBarShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "SyncBarShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "SyncBarShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						SyncBarShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as SyncBarShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of SyncBarShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of SyncBarShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new SyncBarShape instance should be created.</param>	
		/// <returns>Created SyncBarShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new SyncBarShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from SyncBarShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from SyncBarShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(SyncBarShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including SyncBarShape itself) instance of SyncBarShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "SyncBarShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "SyncBarShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						SyncBarShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as SyncBarShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of SyncBarShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, SyncBarShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from SyncBarShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from SyncBarShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(SyncBarShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized SyncBarShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SyncBarShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the SyncBarShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the SyncBarShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one SyncBarShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">SyncBarShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given SyncBarShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">SyncBarShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the SyncBarShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			SyncBarShape instance = element as SyncBarShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of SyncBarShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">SyncBarShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer StateShapeSerializer for DomainClass StateShape.
	/// </summary>
	public partial class StateShapeSerializer : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// StateShapeSerializer Constructor
		/// </summary>
		public StateShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of StateShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"stateShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of StateShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"stateShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of StateShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one StateShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the StateShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory StateShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of StateShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized StateShape, a new StateShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created StateShape instance, or null if the reader is not pointing to a serialized StateShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "StateShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "StateShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						StateShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StateShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of StateShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of StateShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new StateShape instance should be created.</param>	
		/// <returns>Created StateShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new StateShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from StateShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from StateShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(StateShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including StateShape itself) instance of StateShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "StateShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "StateShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						StateShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as StateShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of StateShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, StateShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from StateShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from StateShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(StateShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized StateShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StateShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the StateShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the StateShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one StateShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">StateShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given StateShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">StateShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the StateShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			StateShape instance = element as StateShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of StateShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">StateShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer TaskShapeSerializer for DomainClass TaskShape.
	/// </summary>
	public partial class TaskShapeSerializer : DslDiagrams::CompartmentShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// TaskShapeSerializer Constructor
		/// </summary>
		public TaskShapeSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of TaskShape.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"taskShape"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of TaskShape.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"taskShapeMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of TaskShape in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one TaskShape instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the TaskShape element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory TaskShape instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of TaskShape based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized TaskShape, a new TaskShape instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created TaskShape instance, or null if the reader is not pointing to a serialized TaskShape instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TaskShape" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "TaskShape".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						TaskShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TaskShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of TaskShape based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of TaskShape.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new TaskShape instance should be created.</param>	
		/// <returns>Created TaskShape instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new TaskShape(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from TaskShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from TaskShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TaskShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including TaskShape itself) instance of TaskShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "TaskShape" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "TaskShape".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						TaskShapeSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as TaskShapeSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of TaskShape based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, TaskShape.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from TaskShape, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from TaskShape.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(TaskShape.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized TaskShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TaskShape instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the TaskShape instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the TaskShape instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one TaskShape instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">TaskShape instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given TaskShape instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TaskShape instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the TaskShape instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			TaskShape instance = element as TaskShape;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of TaskShape!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">TaskShape instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer FlowConnectorSerializer for DomainClass FlowConnector.
	/// </summary>
	public partial class FlowConnectorSerializer : DslDiagrams::BinaryLinkShapeSerializer
	{
		#region Constructor
		/// <summary>
		/// FlowConnectorSerializer Constructor
		/// </summary>
		public FlowConnectorSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of FlowConnector.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"flowConnector"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of FlowConnector.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"flowConnectorMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of FlowConnector in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one FlowConnector instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the FlowConnector element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory FlowConnector instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of FlowConnector based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized FlowConnector, a new FlowConnector instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created FlowConnector instance, or null if the reader is not pointing to a serialized FlowConnector instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "FlowConnector" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "FlowConnector".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						FlowConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as FlowConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of FlowConnector based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of FlowConnector.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new FlowConnector instance should be created.</param>	
		/// <returns>Created FlowConnector instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new FlowConnector(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from FlowConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from FlowConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(FlowConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including FlowConnector itself) instance of FlowConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "FlowConnector" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "FlowConnector".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						FlowConnectorSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as FlowConnectorSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of FlowConnector based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, FlowConnector.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from FlowConnector, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from FlowConnector.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(FlowConnector.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized FlowConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">FlowConnector instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the FlowConnector instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the FlowConnector instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one FlowConnector instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">FlowConnector instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given FlowConnector instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">FlowConnector instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the FlowConnector instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			FlowConnector instance = element as FlowConnector;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of FlowConnector!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">FlowConnector instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Serializer AttackDiagramSerializer for DomainClass AttackDiagram.
	/// </summary>
	public partial class AttackDiagramSerializer : DslDiagrams::DiagramSerializer
	{
		#region Constructor
		/// <summary>
		/// AttackDiagramSerializer Constructor
		/// </summary>
		public AttackDiagramSerializer ()
			: base ()
		{
		}
		#endregion
	
		
		#region Miscellaneous methods
	
		/// <summary>
		/// Reset the serializer
		/// </summary>
		/// <remarks>
		/// Clear the cached information about any derived classes so that it is recalculated.
		/// </remarks>
		public override void Reset()
		{
			base.Reset();
			this.derivedClasses = null;
			this.derivedClassMonikers = null;
		}
	
		#endregion
	
		#region Public Properties
		/// <summary>
		/// This is the XML tag name used to serialize an instance of AttackDiagram.
		/// </summary>
		public override string XmlTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"attackDiagram"; }
		}
	
		/// <summary>
		/// This is the XML tag name used to serialize a monikerized instance of AttackDiagram.
		/// </summary>
		public override string MonikerTagName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"attackDiagramMoniker"; }
		}
		
		/// <summary>
		/// This is the name of the XML attribute that stores the moniker of AttackDiagram in a serialized monikerized instance.
		/// </summary>
		public override string MonikerAttributeName
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return @"Id"; }
		}
		#endregion
	
		#region Read Methods
		/// <summary>
		/// Public Read() method that deserializes one AttackDiagram instance from XML.
		/// </summary>
		/// <remarks>
		/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
		/// of the AttackDiagram element that is about to be deserialized. 
		/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
		/// or the close tag of the parent element (or EOF).
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">In-memory AttackDiagram instance that will get the deserialized data.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			#endregion
			
			// Read properties serialized as XML attributes.
			base.ReadPropertiesFromAttributes(serializationContext, element, reader);
	
			// Read nested XML elements.
			if (!serializationContext.Result.Failed)
			{
				if (!reader.IsEmptyElement)
				{
					// Read to the start of the first child element.
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
					// Read any extension element data under this XML element
					AttackSerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
					
					// Read nested XML elements, they can be either properties serialized as XML elements, or child 
					// model elements.
					while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						base.ReadElements(serializationContext, element, reader);
						if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
						{
							// Encountered one unknown XML element, skip it and keep reading.
							AttackSerializationBehaviorSerializationMessages.UnexpectedXmlElement(serializationContext, reader);
							DslModeling::SerializationUtilities.Skip(reader);
						}
					}
				}
			}
	
			// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
			DslModeling::SerializationUtilities.Skip(reader);
		}
		
	
		#region TryCreateInstance
		/// <summary>
		/// This method creates a correct instance of AttackDiagram based on the tag currently pointed by the reader. If the reader
		/// is positioned at a serialized AttackDiagram, a new AttackDiagram instance will be created in the given partition, otherwise 
		/// null is returned.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new elements should be created.</param>	
		/// <returns>Created AttackDiagram instance, or null if the reader is not pointing to a serialized AttackDiagram instance.</returns>
		public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::ModelElement result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "AttackDiagram" instance.
					result = this.CreateInstance(serializationContext, reader, partition);
				}
				else
				{	// Check for derived classes of "AttackDiagram".
					if (this.derivedClasses == null)
						this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class instance.
						AttackDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AttackDiagramSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
					}
				}
			}
	
			return result;
		}
	
		/// <summary>
		/// This method creates an instance of AttackDiagram based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
		/// to be pointed at a serialized instance of AttackDiagram.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="partition">Partition in which new AttackDiagram instance should be created.</param>	
		/// <returns>Created AttackDiagram instance.</returns>
		protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
		{
			string idStr = reader.GetAttribute ("Id");
			try
			{
				global::System.Guid id;
				if (string.IsNullOrEmpty(idStr))
				{	// Create a default Id.
					id = global::System.Guid.NewGuid();
					AttackSerializationBehaviorSerializationMessages.MissingId(serializationContext, reader, id);
				}
				else
				{
					id = new global::System.Guid (idStr);
				}
				return new AttackDiagram(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
			}
			catch (global::System.ArgumentNullException /* anEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			catch (global::System.OverflowException /* ofEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
			}
			return null;
		}
	
		/// <summary>
		/// Stores a mapping from XmlTagName to DomainClassInfo that derives from AttackDiagram, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;
	
		/// <summary>
		/// Construct the apping from XmlTagName to DomainClassInfo that derives from AttackDiagram.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
			this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AttackDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					global::System.Type descendentType = descendent.ImplementationClass;
					if (!descendentType.IsAbstract)
					{
						DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
						if (descendentSerializer != null)
						{
							string descendentXmlTagName = descendentSerializer.XmlTagName;
							if (!string.IsNullOrEmpty (descendentXmlTagName))
							{
								global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
								this.derivedClasses.Add (descendentXmlTagName, descendent);
							}
						}
					}
					else
					{   // Ignore abstract derived classes because they cannot be instantiated directly.
					}
				}
			}
		}
		#endregion
	
		#region TryCreateMonikerInstance
		/// <summary>
		/// This method creates a Moniker of the correct derived (including AttackDiagram itself) instance of AttackDiagram based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException ("reader");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (partition != null);
			if (partition == null)
				throw new global::System.ArgumentNullException ("partition");
			#endregion
	
			DslModeling::Moniker result = null;
			if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			{
				string localName = reader.LocalName;
				if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
				{	// New "AttackDiagram" moniker instance.
					result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
				else
				{	// Check for derived classes of "AttackDiagram".
					if (this.derivedClassMonikers == null)
						this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
					global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
					DslModeling::DomainClassInfo derivedClass = null;
					if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
					{	// New derived class moniker instance.
						AttackDiagramSerializer derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as AttackDiagramSerializer;
						global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
						result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
					}
				}
			}
	
			return result;
		}
		
		/// <summary>
		/// This method creates a Moniker of AttackDiagram based on the tag currently pointed by the reader.
		/// </summary>
		/// <remarks>
		/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
		/// not move the reader; the reader should remain at the same position when this method returns.
		/// </remarks>		
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="reader">XmlReader to read serialized data from.</param>
		/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
		/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
		/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
		/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
		protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
		{
			string monikerString = AttackSerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);
	
			if (string.IsNullOrEmpty(monikerString))
			{	
				AttackSerializationBehaviorSerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
				return null;
			}
			try
			{	// Normalize the Id.
				global::System.Guid id = new global::System.Guid(monikerString);
				monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
				DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, AttackDiagram.DomainClassId, partition.Store), partition.Store);
				// Set location info if possible.
				result.Location = serializationContext.Location;
				global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
				if (xmlLineInfo != null)
				{
					result.Line = xmlLineInfo.LineNumber;
					result.Column = xmlLineInfo.LinePosition;
				}
				return result;
			}
			catch (global::System.FormatException /* fEx */)
			{
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
			catch (global::System.OverflowException /* oEx */)
			{	
				AttackSerializationBehaviorSerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
				return null;
			}
		}
	
		/// <summary>
		/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from AttackDiagram, created on demand.
		/// </summary>
		private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;
	
		/// <summary>
		/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from AttackDiagram.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
		private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
		{
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
			this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);
	
			DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(AttackDiagram.DomainClassId);
			global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
			if (descendents != null)
			{
				foreach (DslModeling::DomainClassInfo descendent in descendents)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentMonikerTagName = descendentSerializer.MonikerTagName;
						if (!string.IsNullOrEmpty (descendentMonikerTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
							this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
						}
					}
				}
			}
		}
		#endregion
		#endregion
	
		#region Write Methods
		/// <summary>
		/// Public WriteMoniker() method that writes a monikerized AttackDiagram instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackDiagram instance to be monikerized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="sourceRolePlayer">Source element that references the AttackDiagram instance being monikerized.</param>
		/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the AttackDiagram instance being monikerized.</param>
		public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
			if (sourceRolePlayer == null)
				throw new global::System.ArgumentNullException ("sourceRolePlayer");
			global::System.Diagnostics.Debug.Assert (relSerializer != null);
			if (relSerializer == null)
				throw new global::System.ArgumentNullException ("relSerializer");
			#endregion
			
			string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
			writer.WriteStartElement(this.MonikerTagName);
			AttackSerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
			writer.WriteEndElement();
		}
		
		/// <summary>
		/// Public Write() method that serializes one AttackDiagram instance into XML.
		/// </summary>
		/// <param name="serializationContext">Serialization context.</param>
		/// <param name="element">AttackDiagram instance to be serialized.</param>
		/// <param name="writer">XmlWriter to write serialized data to.</param>
		/// <param name="rootElementSettings">
		/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
		/// information like schema target namespace, version, etc.
		/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
		/// without this parameter).
		/// </param>
		public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException ("serializationContext");
			global::System.Diagnostics.Debug.Assert (element != null);
			if (element == null)
				throw new global::System.ArgumentNullException ("element");
			global::System.Diagnostics.Debug.Assert (writer != null);
			if (writer == null)
				throw new global::System.ArgumentNullException ("writer");
			#endregion
	
			// Write start of element, including schema target namespace if specified.
			if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
			{
				writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
				DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
			}
			else
			{
				writer.WriteStartElement(this.XmlTagName);
			}
				
			// Write version info (in the format 1.2.3.4), if necessary
			if (rootElementSettings != null && rootElementSettings.Version != null)
				writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
	
			// Write out element Id.
			writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
	
			base.WritePropertiesAsAttributes(serializationContext, element, writer);
	
			// Write out any extension data if this is the root element
			if (rootElementSettings != null && !serializationContext.Result.Failed)
			{
				AttackSerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
			}
	
			if (!serializationContext.Result.Failed)
			{
				// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
				base.WriteElements(serializationContext, element, writer);
			}
	
			writer.WriteEndElement();
		}
		#endregion
	
		#region Moniker Support
		/// <summary>
		/// This method calculates a moniker to a given AttackDiagram instance.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AttackDiagram instance to calculate qualified name for.</param>
		/// <returns>A fully qualified string moniker to the AttackDiagram instance.</returns>
		public override string CalculateQualifiedName(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			AttackDiagram instance = element as AttackDiagram;
			global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of AttackDiagram!");
	
			return instance.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
		}
	
		/// <summary>
		/// A domain class can be monikerized in different ways: standard /qualifier/key mechanism, custom moniker, or element ID. If the domain class is serialized
		/// using standard /qualifier/key mechanism, this method returns the qualifier of the moniker; if the domain class uses other ways for monikerization, this method
		/// returns empty string.
		/// </summary>
		/// <param name="directory">Directory to look up serializer based on model element type.</param>
		/// <param name="element">AttackDiagram instance to get moniker qualifier from.</param>
		/// <returns>
		/// Value of this element's moniker qualifier property, if it has one, or the value of the container's moniker qualifier property. Or empty string if this
		/// element is not monikerized using standard /qualifier/key mechanism.
		/// </returns>
		public override string GetMonikerQualifier(DslModeling::DomainXmlSerializerDirectory directory, DslModeling::ModelElement element)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert (directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException ("directory");
			global::System.Diagnostics.Debug.Assert(element != null);
			if (element == null)
				throw new global::System.ArgumentNullException("element");
			#endregion	
			
			return string.Empty;
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior AttackSerializationBehavior.
	/// This is the abstract base of the double-derived implementation.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
	public abstract class AttackSerializationBehaviorBase : DslModeling::DomainXmlSerializationBehavior
	{
		///<summary>
		/// The xml namespace used by this domain model when serializing
		///</summary>
		public const string DomainModelXmlNamespace = @"http://schemas.microsoft.com/dsltools/Attack";
	
		#region Member Variables
		/// <summary>
		/// A list of DomainClass Ids mapped to DomainClassXmlSerializer types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry> serializerTypes;
	
		/// <summary>
		/// A list of xml namespaces mapped to domain model types.
		/// </summary>
		private static global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry> namespaceEntries;
	
		#endregion
	
		#region Constructor
		/// <summary>
		/// Protected constructor to prevent public instantiation.
		/// </summary>
		protected AttackSerializationBehaviorBase() : base() { }
		#endregion
		
		#region Protected Methods
		/// <summary>
		/// Allows custom serializers to be added.
		/// Base implementation doesn't do anything.
		/// </summary>
		/// <returns>Custom serializer types, null or empty list if there's no custom serializer types.</returns>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected virtual global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> CustomSerializerTypes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
		#endregion
	
		#region Public Methods
		/// <summary>
		/// This provides a mapping from DomainClass Id to DomainXmlSerializer implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> AllSerializers
		{
			get
			{
				if (AttackSerializationBehavior.serializerTypes == null)
				{
					global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerDirectoryEntry> customSerializerTypes = this.CustomSerializerTypes;
					int customSerializerCount = (customSerializerTypes == null ? 0 : customSerializerTypes.Count);
					AttackSerializationBehavior.serializerTypes = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerDirectoryEntry>(22 + customSerializerCount);
	
					#region Serializers defined in this model
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(NamedElement.DomainClassId, typeof(NamedElementSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(AttackGraph.DomainClassId, typeof(AttackGraphSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(FlowElement.DomainClassId, typeof(FlowElementSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Task.DomainClassId, typeof(TaskSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(StartPoint.DomainClassId, typeof(StartPointSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Endpoint.DomainClassId, typeof(EndpointSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(MergeBranch.DomainClassId, typeof(MergeBranchSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Synchronization.DomainClassId, typeof(SynchronizationSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(State.DomainClassId, typeof(StateSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Condition.DomainClassId, typeof(ConditionSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(Flow.DomainClassId, typeof(FlowSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(AttackGraphHasFlowElements.DomainClassId, typeof(AttackGraphHasFlowElementsSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TaskHasPreConditions.DomainClassId, typeof(TaskHasPreConditionsSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(StateHasPostConditions.DomainClassId, typeof(StateHasPostConditionsSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(MergeBranchShape.DomainClassId, typeof(MergeBranchShapeSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(EndShape.DomainClassId, typeof(EndShapeSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(StartShape.DomainClassId, typeof(StartShapeSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(SyncBarShape.DomainClassId, typeof(SyncBarShapeSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(StateShape.DomainClassId, typeof(StateShapeSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(TaskShape.DomainClassId, typeof(TaskShapeSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(FlowConnector.DomainClassId, typeof(FlowConnectorSerializer)));
					AttackSerializationBehavior.serializerTypes.Add(new DslModeling::DomainXmlSerializerDirectoryEntry(AttackDiagram.DomainClassId, typeof(AttackDiagramSerializer)));
					#endregion
					
					// Custom ones
					if (customSerializerCount > 0)
					{
						AttackSerializationBehavior.serializerTypes.AddRange(customSerializerTypes);
					}
				}
				return AttackSerializationBehavior.serializerTypes.AsReadOnly();
			}
		}
		
		/// <summary>
		/// This provides a mapping from xml namespaces to domain model implementation types.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		//[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
		public override global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainXmlSerializerNamespaceEntry> AllNamespaces
		{
			get
			{
				if (AttackSerializationBehavior.namespaceEntries == null)
				{
					AttackSerializationBehavior.namespaceEntries = new global::System.Collections.Generic.List<DslModeling::DomainXmlSerializerNamespaceEntry>();
					AttackSerializationBehavior.namespaceEntries.Add(new DslModeling::DomainXmlSerializerNamespaceEntry(DomainModelXmlNamespace, typeof(global::JA.Attack.AttackDomainModel)));
				}
				return AttackSerializationBehavior.namespaceEntries.AsReadOnly();
			}
		}
		
		#endregion
	}
	
	/// <summary>
	/// A DomainXmlSerializationBehavior implementation for defined behavior AttackSerializationBehavior.
	/// This is the concrete type of the double-derived implementation.
	/// </summary>
	public sealed partial class AttackSerializationBehavior : AttackSerializationBehaviorBase
	{
		#region Singleton Instance
		/// <summary>
		/// Singleton instance.
		/// </summary>
		private static AttackSerializationBehavior instance;
	
		/// <summary>
		/// Singleton instance.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable (global::System.Diagnostics.DebuggerBrowsableState.Never)]	// Will trigger creation otherwise.
		public static AttackSerializationBehavior Instance
		{
			get
			{	// No need for synchronization. Most likely running in single-thread environment, and creating an extra instance
				// doesn't really hurt.
				if (AttackSerializationBehavior.instance == null)
					AttackSerializationBehavior.instance = new AttackSerializationBehavior ();
				return AttackSerializationBehavior.instance;
			}
		}
	
		/// <summary>
		/// Private constructor to prevent public instantiation.
		/// </summary>
		private AttackSerializationBehavior() : base() { }
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Moniker resolver for serialization behavior AttackSerializationBehavior.
	/// </summary>
	public partial class AttackSerializationBehaviorMonikerResolver : AttackSerializationBehaviorMonikerResolverBase
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public AttackSerializationBehaviorMonikerResolver(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base(store,directory)
		{
		}
	}
	
	/// <summary>
	/// Base moniker resolver for serialization behavior AttackSerializationBehavior.
	/// </summary>
	public partial class AttackSerializationBehaviorMonikerResolverBase : DslModeling::SimpleMonikerResolver
	{
		#region Member Variables
		/// <summary>
		/// Look-up directory to find serializers for domain classes.
		/// </summary>
		private DslModeling::DomainXmlSerializerDirectory directory;
		#endregion
	
		#region Constructor
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="store">Store for this moniker resolver.</param>
		/// <param name="directory">Directory to used by this resolver to look up for serializers.</param>
		public AttackSerializationBehaviorMonikerResolverBase(DslModeling::Store store, DslModeling::DomainXmlSerializerDirectory directory)
			: base (store)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(directory != null);
			if (directory == null)
				throw new global::System.ArgumentNullException("directory");
			#endregion
	
			this.directory = directory;
		}
		#endregion
	
		#region Base Overrides
		/// <summary>
		/// Tells if a DomainClass can be monikerized or not.
		/// </summary>
		/// <param name="domainClassInfo">DomainClassInfo of the DomainClass to be checked.</param>
		/// <returns>True if the DomainClass can be monikerized, false otherwise.</returns>
		protected override bool CanBeMonikerized(DslModeling::DomainClassInfo domainClassInfo)
		{
			if (this.IsDisposed || this.directory == null || domainClassInfo == null)
				return false;
				
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(domainClassInfo.Id);
			if (serializer != null)
				return (!string.IsNullOrEmpty(serializer.MonikerTagName));
			return false;
		}
			
		/// <summary>
		/// Calculate the fully qualified monikerized string of the given ModelElement.
		/// </summary>
		/// <param name="mel">ModelElement to get moniker from.</param>
		/// <returns>Calculated moniker string, returns null or empty string is the given ModelElement cannot be monikerized.</returns>
		protected override string CalculateQualifiedName(DslModeling::ModelElement mel)
		{
			if (this.IsDisposed || this.directory == null || mel == null)
				return string.Empty;
	
			string result = string.Empty;
			DslModeling::DomainClassXmlSerializer serializer = this.directory.GetSerializer(mel.GetDomainClass().Id);
			if (serializer != null)
				result = serializer.CalculateQualifiedName(this.directory, mel);
			return result;
		}
		
		/// <summary>
		/// Called at the end of synchronization when they're unresolved monikers.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		protected override void OnUnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				AttackSerializationBehaviorSerializationMessages.UnresolvedMoniker(serializationResult, moniker);
			}
		}
		
		/// <summary>
		/// Called when resolving a moniker causes a duplicate link to be created.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to store error/warning messages.</param>
		/// <param name="moniker">Moniker that causes duplicate link to be created.</param>
		protected override void OnMonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			if (serializationResult != null)
			{
				AttackSerializationBehaviorSerializationMessages.MonikerResolvedToDuplicateLink(serializationResult, moniker);
			}
			base.OnMonikerResolvedToDuplicateLink(serializationResult, moniker);
		}
		
		/// <summary>
		/// Called when two new elements are giving the same moniker, which will cause ambiguity during moniker resolution.
		/// </summary>
		/// <param name="context">SerializationContext to store error/warning messages.</param>
		/// <param name="moniker">Moniker that both elements give.</param>
		/// <param name="element1">The first element giving the moniker.</param>
		/// <param name="element2">The second element giving the same moniker.</param>
		protected override void OnAmbiguousMoniker(DslModeling::SerializationContext context, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			if (context != null)
			{
				AttackSerializationBehaviorSerializationMessages.AmbiguousMoniker(context, moniker, element1, element2);
			}
			base.OnAmbiguousMoniker(context, moniker, element1, element2);
		}
		
		/// <summary>
		/// Error message for UnresolvedMonikerException.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
		protected override string UnresolvedMonikerExceptionMessage
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return AttackSerializationBehaviorSerializationMessages.ResourceManager.GetString("CannotOpenDocument"); }
		}
		#endregion
	}
}

namespace JA.Attack
{
	/// <summary>
	/// Utility class to provide serialization messages
	/// </summary>
	public static partial class AttackSerializationBehaviorSerializationMessages
	{
		/// <summary>
		/// ResourceManager to get serialization messages from.
		/// </summary>
		[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)] // Will trigger creation otherwise.
		public static global::System.Resources.ResourceManager ResourceManager
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return AttackDomainModel.SingletonResourceManager; }
		}
	
		#region Warnings
		/// <summary>
		/// Add a warning for ambiguous schemas.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace to be resolved.</param>
		/// <param name="schemaPath">The schema that is used to resolve the definition of the target namespace.</param>
		public static void AmbiguousSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace, string schemaPath)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(schemaPath));
			if (string.IsNullOrEmpty(schemaPath))
				throw new global::System.ArgumentNullException("schemaPath");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousSchema"),
					targetNamespace,
					schemaPath
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a full-form relationship seems to be serialized in short-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingFullFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingFullFormRelationship"),
					reader.Name,
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning when a short-form relationship seems to be serialized in full-form.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type of the relationship.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the relationship, making it MemberInfo only adds confusion.")]
		public static void ExpectingShortFormRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Type relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(relationshipType != null);
			if (relationshipType == null)
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("ExpectingShortFormRelationship"),
					relationshipType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for invalid property value with the given type, which will be ignored.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this warning.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void IgnoredPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("IgnoredPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for missing "Id" property.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="newId">Auto-generated new Id.</param>
		public static void MissingId(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Guid newId)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingId"),
					newId.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
			
		/// <summary>
		/// Add an warning for moniker resolved to duplicate link. The moniker will be ignored.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Offending moniker.</param>
		public static void MonikerResolvedToDuplicateLink(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MonikerResolvedToDuplicateLink"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
		
		/// <summary>
		/// Add a warning for no schema found for the given target namespace, schema validation will be skipped in this case.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="targetNamespace">Target namespace that cannot be resolved.</param>
		public static void NoSchema(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string targetNamespace)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(targetNamespace));
			if (string.IsNullOrEmpty(targetNamespace))
				throw new global::System.ArgumentNullException("targetNamespace");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("NoSchema"),
					targetNamespace
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add a warning for schema validation error.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="message">Validation message reported from schema validation.</param>
		public static void SchemaValidationError(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string message)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(message));
			if (string.IsNullOrEmpty(message))
				throw new global::System.ArgumentNullException("message");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				message,
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an warning for unexpected XML element.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the warning message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		public static void UnexpectedXmlElement(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			#endregion
				
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Warning,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnexpectedXmlElement"),
					reader.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	
		#region Errors
		/// <summary>
		/// Add an error for ambiguous moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="moniker">The ambiguous moniker string.</param>
		/// <param name="element1">The first element using the given moniker.</param>
		/// <param name="element2">The second element using the given moniker.</param>
		public static void AmbiguousMoniker(DslModeling::SerializationContext serializationContext, string moniker, DslModeling::ModelElement element1, DslModeling::ModelElement element2)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			global::System.Diagnostics.Debug.Assert(element1 != null);
			if (element1 == null)
				throw new global::System.ArgumentNullException("element1");
			global::System.Diagnostics.Debug.Assert(element2 != null);
			if (element2 == null)
				throw new global::System.ArgumentNullException("element2");
			#endregion
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("AmbiguousMoniker"),
					moniker,
					DslModeling::SerializationUtilities.GetElementName(element1),
					DslModeling::SerializationUtilities.GetElementName(element2)
				),
				null	// No location info available
			);
		}
		
		/// <summary>
		/// Add an error for not able to monikerize an instance of the given DomainClass.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="domainClassName">Name of the DomainClass whose instance cannot be monikerized.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", Justification = "Generated code.")]	
		public static void CannotMonikerizeElement(DslModeling::SerializationContext serializationContext, string domainClassName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(domainClassName));
			if (string.IsNullOrEmpty(domainClassName))
				throw new global::System.ArgumentNullException("domainClassName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext.Result,
				null,	/* no location available for this error, because save failed. */
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("CannotMonikerizeElement"),
					domainClassName
				),
				0,
				0
			);
		}
		
		/// <summary>
		/// Add an error for dangling relationship instance.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="relationshipType">Type name of the relationship.</param>
		public static void DanglingRelationship(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string relationshipType)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(relationshipType));
			if (string.IsNullOrEmpty(relationshipType))
				throw new global::System.ArgumentNullException("relationshipType");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("DanglingRelationship"),
					relationshipType
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for invalid property value with given type.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="propertyName">Name of the property.</param>
		/// <param name="propertyType">Type of the property.</param>
		/// <param name="value">Invalid value that causes this error.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "This is the type of the property, making it MemberInfo only adds confusion.")]
		public static void InvalidPropertyValue(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string propertyName, global::System.Type propertyType, string value)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(propertyType != null);
			if (propertyType == null)
				throw new global::System.ArgumentNullException("propertyType");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(propertyName));
			if (string.IsNullOrEmpty(propertyName))
				throw new global::System.ArgumentNullException("propertyName");
			#endregion
			
			if (value == null)
				value = "<null>";
	
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("InvalidPropertyValue"),
					value,
					propertyName,
					propertyType.Name
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for missing moniker.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="monikerAttributeName">Name of the attribute that should hold the moniker.</param>
		public static void MissingMoniker(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, string monikerAttributeName)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerAttributeName));
			if (string.IsNullOrEmpty(monikerAttributeName))
				throw new global::System.ArgumentNullException("monikerAttributeName");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("MissingMoniker"),
					monikerAttributeName
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		
		/// <summary>
		/// Add an error for unresolved moniker.
		/// </summary>
		/// <param name="serializationResult">SerializationResult to add the error message to.</param>
		/// <param name="moniker">Unresolved moniker.</param>
		public static void UnresolvedMoniker(DslModeling::SerializationResult serializationResult, DslModeling::Moniker moniker)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationResult != null);
			if (serializationResult == null)
				throw new global::System.ArgumentNullException("serializationResult");
			global::System.Diagnostics.Debug.Assert(moniker != null);
			if (moniker == null)
				throw new global::System.ArgumentNullException("moniker");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationResult,
				moniker.Location,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("UnresolvedMoniker"),
					moniker.MonikerName
				),
				moniker.Line,
				moniker.Column
			);
		}
	
		/// <summary>
		/// Add an error for Version mismatch.
		/// </summary>
		/// <param name="serializationContext">SerializationContext to add the error message to.</param>
		/// <param name="reader">The reader pointing to where the message is raised.</param>
		/// <param name="expectedVersion">The version that's expected.</param>
		/// <param name="actualVersion">Actual version from the file.</param>
		public static void VersionMismatch(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, global::System.Version expectedVersion, global::System.Version actualVersion)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(serializationContext != null);
			if (serializationContext == null)
				throw new global::System.ArgumentNullException("serializationContext");
			global::System.Diagnostics.Debug.Assert(reader != null);
			if (reader == null)
				throw new global::System.ArgumentNullException("reader");
			global::System.Diagnostics.Debug.Assert(expectedVersion != null);
			if (expectedVersion == null)
				throw new global::System.ArgumentNullException("expectedVersion");
			global::System.Diagnostics.Debug.Assert(actualVersion != null);
			if (actualVersion == null)
				throw new global::System.ArgumentNullException("actualVersion");
			#endregion
			
			DslModeling::SerializationUtilities.AddMessage(
				serializationContext,
				DslModeling::SerializationMessageKind.Error,
				string.Format(
					global::System.Globalization.CultureInfo.CurrentCulture,
					ResourceManager.GetString("VersionMismatch"), 
					actualVersion.ToString(4), 
					expectedVersion.ToString(4)
				),
				reader as global::System.Xml.IXmlLineInfo
			);
		}
		#endregion
	}
}
namespace JA.Attack
{
	/// <summary>
	/// Provides an implementation of the IDomainModelSerializer interface
	/// that can be used to serialize / deserialize the Attack domain model.
	/// </summary>
	/// <remarks>Double-derived class - the default implementation is in AttackDomainModelSerializerBase.
	/// This class exist so users can customize behavior easily.</remarks>
	[global::System.ComponentModel.Composition.Export(typeof(DslModeling::IDomainModelSerializer))]
	[DslModeling::DomainModelSerializer(typeof(global::JA.Attack.AttackDomainModel), global::JA.Attack.AttackSerializationBehavior.DomainModelXmlNamespace, "Attack")]
	public partial class AttackDomainModelSerializer : AttackDomainModelSerializerBase
	{
	}
	
	
	/// <summary>
	/// Base class that implements IDomainModelSerializer
	/// </summary>
	public abstract partial class AttackDomainModelSerializerBase : DslModeling::IDomainModelSerializer
	{
	
		#region Public properties
	
		/// <summary>
		/// The XML namespace used when serializing the domain model
		/// </summary>
		public virtual string DomainModelNamespace
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return global::JA.Attack.AttackSerializationBehavior.DomainModelXmlNamespace; }
		}
	
		/// <summary>
		/// Returns true: this DSL can be serialized / deserialized directly.
		/// </summary>
		public virtual bool IsSerializable
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return true; }
		}
	
		/// <summary>
		/// The type of the domain model
		/// </summary>
		public virtual global::System.Type DomainModelType
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return typeof(global::JA.Attack.AttackDomainModel); }
		}
	
		/// <summary>
		/// File extension used for model files of this kind of domain model
		/// </summary>
		/// <remarks>If a domain model type cannot be serialized independently, or cannot
		/// be serialized to a file, it should return null or empty.</remarks>
		public string ModelFileExtension
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return "Attack"; }
		}
	
		#endregion
		
		
		#region Load / Save model methods
		
		/// <summary>
		/// Loads a AttackGraph instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="partition">Partition in which the new AttackGraph instance will be created.</param>
		/// <param name="fileName">Name of the file from which the AttackGraph instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded AttackGraph instance.</returns>
		public virtual DslModeling::ModelElement LoadModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition partition, 
			string fileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (partition == null) { throw new global::System.ArgumentNullException("partition"); }
			if (string.IsNullOrEmpty(fileName)) { throw new global::System.ArgumentNullException("fileName"); }
	
			return AttackSerializationHelper.Instance.LoadModel(serializationResult, partition, fileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given model root to the given file, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">AttackGraph instance to be saved.</param>
		/// <param name="fileName">Name of the file in which the AttackGraph instance will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the AttackGraph instance.</param>
		public void SaveModel(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string fileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("fileName")) { throw new global::System.ArgumentNullException("fileName"); }
	
			global::JA.Attack.AttackGraph rootElement = modelRoot as global::JA.Attack.AttackGraph;
			if (rootElement == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::JA.Attack.AttackDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
	
			}
	
			AttackSerializationHelper.Instance.SaveModel(serializationResult, rootElement, fileName,encoding, true);
		}
	
		#endregion
	
		#region Load / Save model and diagram methods
	
		/// <summary>
		/// Calculates and returns the name of the diagram file for the specified model file
		/// </summary>
		/// <param name="modelFileName">The relevant model file name</param>
		/// <returns>Name of the associated diagram file</returns>
		/// <remarks>There is no guarantee that either the model file or the calculated diagram file exist.</remarks>
		public virtual string CalculateDiagramFileName(string modelFileName)
		{
			if (string.IsNullOrEmpty(modelFileName))
			{
				throw new global::System.ArgumentNullException("modelFileName");
			}
			return modelFileName + ".diagram";
		}
	
		/// <summary>
		/// Loads a AttackGraph instance and its associated diagram file.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the load operation.</param>
		/// <param name="modelPartition">Partition in which the new AttackGraph instance will be created.</param>
		/// <param name="modelFileName">Name of the file from which the AttackGraph instance will be deserialized.</param>
		/// <param name="diagramPartition">Partition in which the new AttackDiagram instance will be created.</param>
		/// <param name="diagramFileName">Name of the file from which the AttackDiagram instance will be deserialized.</param>
		/// <param name="serializerLocator">Used to locate any additional domain model types required to load the model. Can be null.</param>
		/// <returns>The loaded AttackGraph instance.</returns>
		public DslModeling::ModelElement LoadModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::Partition modelPartition, 
			string modelFileName, 
			DslModeling::Partition diagramPartition, 
			string diagramFileName, 
			DslModeling::ISerializerLocator serializerLocator)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelPartition == null) { throw new global::System.ArgumentNullException("modelPartition"); }
			if (string.IsNullOrEmpty(modelFileName)) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagramPartition == null) { throw new global::System.ArgumentNullException("diagramPartition"); }
			if (string.IsNullOrEmpty(diagramFileName)) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			return AttackSerializationHelper.Instance.LoadModelAndDiagram(serializationResult, modelPartition, modelFileName, diagramPartition, diagramFileName, null, null, serializerLocator);
		}
	
		/// <summary>
		/// Saves the given AttackGraph and AttackDiagram to the given files, with specified encoding.
		/// </summary>
		/// <param name="serializationResult">Stores serialization result from the save operation.</param>
		/// <param name="modelRoot">AttackGraph instance to be saved.</param>
		/// <param name="modelFileName">Name of the file in which the CanonicalSampleRoot instance will be saved.</param>
		/// <param name="diagram">AttackDiagram to be saved.</param>
		/// <param name="diagramFileName">Name of the file in which the diagram will be saved.</param>
		/// <param name="encoding">Encoding to use when saving the diagram.</param>
		public void SaveModelAndDiagram(DslModeling::SerializationResult serializationResult, 
			DslModeling::ModelElement modelRoot, 
			string modelFileName, 
			DslModeling::ModelElement diagram, 
			string diagramFileName, 
			System.Text.Encoding encoding)
		{
			if (serializationResult == null) { throw new global::System.ArgumentNullException("serializationResult"); }
			if (modelRoot == null) { throw new global::System.ArgumentNullException("modelRoot"); }
			if (string.IsNullOrEmpty("modelFileName")) { throw new global::System.ArgumentNullException("modelFileName"); }
			if (diagram == null) { throw new global::System.ArgumentNullException("diagram"); }
			if (string.IsNullOrEmpty("diagramFileName")) { throw new global::System.ArgumentNullException("diagramFileName"); }
	
			global::JA.Attack.AttackGraph typedRoot = modelRoot as global::JA.Attack.AttackGraph;
			if (typedRoot == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::JA.Attack.AttackDomainModel.SingletonResourceManager.GetString("InvalidSaveRootElementType"),
					modelRoot.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "modelRoot");
			}
			global::JA.Attack.AttackDiagram typedDiagram = diagram as global::JA.Attack.AttackDiagram;
			if (typedDiagram == null)
			{
				string errorMessage = string.Format(global::System.Globalization.CultureInfo.CurrentCulture,
					global::JA.Attack.AttackDomainModel.SingletonResourceManager.GetString("InvalidSaveDiagramType"),
					diagram.GetType().ToString());
	
				throw new global::System.ArgumentException(errorMessage, "diagram");
			}
	
			AttackSerializationHelper.Instance.SaveModelAndDiagram(serializationResult, typedRoot, modelFileName, typedDiagram, diagramFileName, encoding, true);
		}
	
		#endregion
		
	}
}


